## 1 Introduction

Network: an infrastructure allows distributed users to communicate with each other. Assumes infra is shared by many users.

Electric Telegraph networks: message switching & store-and-forward operations. Key elements: **Addressing, Routing, Forwarding**.

Inter-net: a network of networks. Connected by using routers & other devices for security, etc. Managed by different organizations.

The Internet: the interconnected set of networks of the **Internet Service Providers (ISPs)**. Objective: diverse applications, devices, infras. An engineered system.

To inter-operate, all participating networks must follow a common set of rules: protocols = interfaces between modules. E.g., address format, header info, packet size limit, etc.

A simple service model: internet: best-effort: packets can get lost.

Some need reliable data delivery, low latency.

-   Horizontally: networks.
-   Vertically: protocols.

Cores

-   Core networking protocols: IP, TCP, Routing
-   Optimization & Perf: QoS, Caching, CNDs, P2P
-   Security, Management
-   IP: The internet, last mile, wireless, data center
-   Infrastructure: Ethernet, WiFi

## 2 Protocol Stacks

The starting point: telephone network in 1960s. The communication steps:

|                      | No. | Connections            | Actions                                                      |
|----------------------|-----|------------------------|--------------------------------------------------------------|
| Connection set up    | 1   | A -> Telephone network | Pick up phone                                                |
|                      | 2   | A <- Telephone network | Dial tone                                                    |
|                      | 3   | A -> Telephone network | Dial number                                                  |
|                      | 4   | A <- Telephone network | Network selects route; sets up circuit; Called party alerted |
| Information Transfer | 5   | A <-> network <-> B    | Exchange voice signals                                       |
| Connection release   | 6   | A x network x B        | Hang up                                                      |

### Circuit Switching vs Packet Switching

Src establishes a connection (circuit) to Dst. Each Switch along the path stores infos about the connection, i.e., 2 wires are connected. Then an actual circuit is connected. But the short comings: e.g., burst traffic, idle circuit.

Src sends the info as *self-contained message with address*. Can break up single message to multiple packets. Each packet independently travels to dst. Switches decides the path and do *store-and-forward* like mail system.

Statistical multiplexing: users use packets (fine grain) to share the wires. Links are not idle.

Store-and-Forward architecture:

-   Packets are self contained units
-   Have more paths to choose -- more robust
-   Requries bufferign to absorb bursts

The challenges: congestion, delay.

### Design a large Internet

Large internet is not more difficult than telephone network.

#### Protocols: Enable Communication

**Protocols** is an agreement between parties on how to communicate. Need to define syntax & semantics. Also break the internet into modules with well-defined interfaces.



## 1 – Introduction, Networking Basics

Regardless of the medium, every network has different bandwidth and latency:

**Bandwidth (capacity)** : width of the link, the number of bits sent or received per unit time (bits/second or bps) 

**Latency (delay)** : length of the link, the propagation time for data to travel along the link (seconds) 

Then the packet delay is

$$Packet Delay = \frac{Data Size}{Link Bandwidth} + Link Latency$$


Use switched network to manage multiple nodes:

**Circuit Switching**: Used in the telephone network

Circuit: The connection established by the interior switches. The circuit would be torn down at last.

Pros: Guaranteed performance and fast transfer (once the circuit is established)

Cons: Waste bandwidth if traffic is bursty (the established circuit idles) and the connection setup time is overhead. The recovery from failure is slow since circuit switching relies on physical machine.

**Packet Switching**: Used in the Internet

Packet: Data be sent as chunks of formatted bits. Packets consist of a header and payload:

**Header**: Instructions to the network for how to handle the packet. Like an envelope.

**Payload**: Data being carried.

Switches forward packets based on their headers, using \underline{\texttt{Destination $\rightarrow$ Next Hop}} table to jump to next switch. The switch in the middle waits for the whole packet to arrive. Then it reads and re-sends the packet to the next stop.

Each packet travels independently.

## 2 – Local Area Networks, Intradomain Routing

**Address Schema**

**Media Access Control Address (MAC)} is used as part of Ethernet Protocol. MAC address is 48 bits long, e.g. \texttt{34:f3:e4:ae:66:44**. All MAC addresses are assigned by the device manufacturer. It’s unique to the device. 

**Ethernet Packet}, aka \hl{Frame} and \hl{Datagram** has 7 parts:

\begin{enumerate}
\item \textit{Preamble}: \texttt{101010} $\cdots$ 56 bits 
\item \textit{SFD}: \texttt{10101011}
\item \textit{Destination MAC Address}: The MAC Address of the host to send the packet to.
\item \textit{Source MAC Address}: The MAC Address of the host who is sending the packet.
\item \textit{EtherType}: Type of data inside the packet.
\item \textit{Payload}: Data to be sent.
\item \textit{FCS}: Frame check sequence. Helps to detect errors in the packet.
\end{enumerate}


**Routing Algorithm**


**1 - Boardcast + Learning Bridges**

Boardcast the packet to every switch, while only the receiver server responses.

Learning Bridges: Every switch maintains a table: \underline{\texttt{MAC Address $\rightarrow$ Switch Port}}

The learning switch algorithm:

\begin{verbatim}
    ReceivePacket(packet, ingress_port)
    {
        if (table.HasAddress(packet.source_mac_address) == False)
        {
            table.InsertEntry(packet.source_mac_address, ingress_port);
        }

        if (table.HasAddress(packet.destination_mac_address) == False)
        {
            foreach (egress_port in port_list)
            {
                if (egress_port != ingress_port)
                {
                    SendPacket(packet, egress_port);
                }
            }
        }
        else
        {
            egress_port = table.GetPort(packet.destination_mac_address);
            SendPacket(packet, egress_port);
        }
    }
\end{verbatim}

Pros: Self-Organizing. Hardware and algorithms are fairly simple. Each switch maintains $O(\#Hosts)$ states.

Cons: Loops or **Boardcast Storm**. Use Spanning Tree Algorithm to reduce the topology graph to a tree while all LAN segments are still connected to the LAN.


**2 - Boardcast + Learning Bridges + Distributed Spanning Tree**

Bridge/Switch/Router with lowest MAC address is tree root. Each bridge remembers the port that is on the shortest path to the root. So every switch maintains a data structure:

\begin{center}
\texttt{(Root, Shortest Path Length to Root, Next Hop)}
\end{center}

The switch/bridge algorithm:

\begin{verbatim}
    // initialization
    root = switch.mac_address;
    path_length = 0;
    next_hop = switch.mac_address;

    while (converge == False)
    {
        // send to neighbors
        foreach (port in port_list)
        {
            Send(port, root, path_length, switch.mac_address);
        }

        // listen from neighbors and update
        foreach (port in port_list)
        {
            n_root, n_path_length, n_mac_address = Listen(port);

            if (n_root < root)
            {
                root = n_root;
                path_length = n_path_length + 1;
                next_hop = n_mac_address;
            }
            else if (n_root == root)
            {
                if (n_path_length < path_length)
                {
                    path_length = n_path_length + 1;
                    next_hop = n_mac_address;
                }
            }
        }
    }
\end{verbatim}

When the switches do not receive message any more, the protocol has converged. 


**3 - Distance Vector Algorithm (Routing Information Protocol, RIP)**

Boardcast Routing is used in very small networks only, since there is $O(\# Nodes)$ time cost. 
In distance vector algorithm, each router maintains its shortest distance to every destination via each of its neighbors. The link distance could be the latency of the link, etc. 
For example, the topology graph:

\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
 & to A & to B & to C & to D \\
\hline
A & 0 ms & 1 ms & 1 ms & Not Connected \\
\hline
B & 1 ms & 0 ms & 3 ms & 3 ms \\
\hline
C & 1 ms & 3 ms & 0 ms & 2 ms \\
\hline
D & Not Connected & 3 ms & 2 ms & 0 ms\\
\hline
\end{tabular}
\end{center}

Then the route table of A will computes the shortest distance to every destination (B, C, D) via any of its neighbors (B and C):

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
 & to B & to C & to D \\
\hline
via B & 1 ms & 4 ms & 4 ms \\
\hline
via C & 4 ms & 1 ms & 3 ms \\
\hline
\end{tabular}
\end{center}

Then the min-distance vector of A would be

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
to A & to B & to C & to D \\
\hline
0 ms & 4 ms & 1 ms & 3 ms \\
\hline
\end{tabular}
\end{center}

Routers use neighbors’ distance vectors to learn route table, especially when start from a almost empty table. That’s to say, router chooses to go to destination via one hop on its neighbor or from the current port directly. Routers exchange their distance vectors with neighbors and update their own routing tables and distance vectors. This process will continue until convergence.

\begin{verbatim}
    while (converge == False)
    {
    // lock phase: all routers send out a DV to neighbors
    await SendDistanceVector(distance_vec, neighbor_list);

    // update phase: unlocked
    // all routers update tables at the same time
        foreach (n_router in neighbor_list)
        {
            // every neighbor
            n_dv = GetDistanceVector(n_router);
            foreach (d_router in router_list)
            {
                // every destinations

                // (destination, port) pair
                if (router_table(
                        d_router, 
                        n_router) > 1 + n_dv(d_router))
                {
                    router_table(
                        d_router, 
                        n_router) = 1 + n_dv(d_router);
                    
                    // update self distance vector
                    if (distance_vec(d_router) > 
                        router_table(d_router, n_router))
                    {
                        distance_vec(d_router) = 
                        router_table(d_router, n_router);
                    }
                }
            }
        }
    }
\end{verbatim}

In $k^{th}$ round, the routers would get best $(k+1)$-hop paths. The algorithm will converge eventually.


\textit{Trade-Off of the algorithms}

\textbf{Resilience}: The ability to provide and maintain an acceptable level of service in the face of faults and challenges to normal operation.

\textbf{Fully Distributed}: Does not assume the previous existence of a central coordinator.

\textbf{State}: The amount of memory each node uses.

\textbf{Convergence}: The process of routers agreeing on optimal routes for forwarding packets and thereby completing the updating of their routing table.

\underline{Boardcast + Learning Bridges}

\begin{enumerate}
\item Resilience: Packets are can be rec-eived if the route exists
\item Fully Distributed: Yes
\item State per Node: $O(\#Nodes)$
\item Convergence: No setup time
\item Routing Efficiency: Boardcast storms
\item Shortest Path: Not necessarily
\end{enumerate}

\underline{Boardcast + Learning Bridges + Distributed Spanning Tree}

\begin{enumerate}
\item Resilience: Need to recompute spanning tree if failure
\item Fully Distributed: Yes
\item State per Node: $O(\#Nodes) + O(Tree Height)$
\item Convergence: Run spanning tree protocol before routing
\item Routing Efficiency: Still sends new connections everywhere
\item Shortest Path: Not necessarily
\end{enumerate}

\underline{Distance Vector}

\begin{enumerate}
\item Resilience: Long converge time when link weights increase or when links go down
\item Fully Distributed: Yes
\item State per Node: $O(\#Nodes) \times \max\{Node Degree\}$
\item Convergence: Need to run DV before routing. $O(\max\{Best Path\})$
\item Routing Efficiency: Packets sent directly to their destination
\item Shortest Path: Yes
\end{enumerate}

## 3 – Local Area Networks, Intradomain Routing

In Distance Vector algorithm, when link updates happen, e.g. link fails or be more expensive (link latency be higher), loopy routing may exist. This is **Count to Infinity Routing** problem. The root of the problem is that DV algorithm has no way to detect and prevent loops. To mitigate the problem, there are three techniques:

\begin{enumerate}
\item \textit{Split Horizon/Poison Reverse}
\item \textit{Maximum Path Lengths}
\item \textit{Pushdown Timers}
\end{enumerate}

**Link State Algorithm (Open Shortest Path First, OSPF)**





